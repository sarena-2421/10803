<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>108èª²ç¶±å­¸æ¸¬åœ‹æ–‡æ¨¡æ“¬App - åœ‹ç¶œæ¸¬é©—</title>
    <!-- å¼•å…¥ React å’Œ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- å¼•å…¥ Babel ç”¨æ–¼è§£æ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .font-serif { font-family: 'Noto Serif TC', serif; }
        .animate-fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body class="bg-slate-200 h-screen w-full flex justify-center items-center overflow-hidden">
    <div id="root" class="w-full max-w-3xl h-full bg-white shadow-2xl relative"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // -----------------------------------------------------------------------------
        // 0. å…§å»ºåœ–æ¨™å…ƒä»¶ (ç§»é™¤å¤–éƒ¨ä¾è³´ä»¥é¿å…éŒ¯èª¤)
        // -----------------------------------------------------------------------------
        const Icons = {
            Brain: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></svg>,
            Compass: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/></svg>,
            Home: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>,
            Grid: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/></svg>,
            Flag: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/><line x1="4" x2="4" y1="22" y2="15"/></svg>,
            ChevronLeft: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m15 18-6-6 6-6"/></svg>,
            ChevronRight: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m9 18 6-6-6-6"/></svg>,
            Award: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></svg>,
            Tag: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94 .94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/></svg>,
            XCircle: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>,
            RotateCcw: (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        };

        // -----------------------------------------------------------------------------
        // 1. çœŸå¯¦é¡Œåº«ç¯„ä¾‹
        // -----------------------------------------------------------------------------
        const REAL_QUESTION_EXAMPLES = [
            {
                id: 'real_gs_1',
                type: 'single',
                category: 'é‚è¼¯æ¨è«–',
                text: 'ä¸‹åˆ—æ–‡å¥ï¼Œé‚è¼¯æ¨è«–æœ€ç‚ºåˆç†çš„æ˜¯ï¼š',
                options: [
                    'å› ç‚ºä»–æ¯å¤©é‹å‹•ï¼Œæ‰€ä»¥èº«é«”ä¸€å®šå¾ˆå¥åº·ï¼Œçµ•å°ä¸æœƒç”Ÿç—…ã€‚',
                    'åªè¦åŠªåŠ›å”¸æ›¸ï¼Œè€ƒè©¦æˆç¸¾å°±ä¸€å®šæœƒååˆ—å‰èŒ…ã€‚',
                    'è‹¥é€™å®¶é¤å»³çš„è©•åƒ¹å¾ˆé«˜ï¼Œé‚£éº¼å®ƒçš„é¤é»å“è³ªæ‡‰è©²å…·æœ‰ä¸€å®šæ°´æº–ã€‚',
                    'ä»–ä¸å–œæ­¡åƒé’æ¤’ï¼Œå¯è¦‹ä»–æ˜¯ä¸€å€‹éå¸¸æŒ‘é£Ÿã€é›£ç›¸è™•çš„äººã€‚'
                ],
                correctAnswer: [2],
                explanation: 'A. ã€Œçµ•å°ä¸æœƒã€å¤ªæ­¦æ–·ï¼› B. ã€Œä¸€å®šã€å¤ªæ­¦æ–·ï¼Œæˆç¸¾å—å¤šé‡å› ç´ å½±éŸ¿ï¼› C. ã€Œæ‡‰è©²ã€è¡¨æ¨æ¸¬ï¼Œç¬¦åˆé‚è¼¯ä¸Šçš„è“‹ç„¶æ€§ï¼Œæœ€ç‚ºåˆç†ï¼› D. éåº¦æ¨è«–ï¼Œä¸åƒé’æ¤’ä¸ç­‰æ–¼é›£ç›¸è™•ã€‚',
                difficulty: 'æ˜“'
            },
            {
                id: 'real_gs_2',
                type: 'single',
                category: 'æ–‡å¥é‡çµ„',
                text: 'ä¸‹åˆ—æ–‡å¥é‡çµ„ï¼Œé †åºæœ€æ°ç•¶çš„æ˜¯ï¼š\nç”²ã€ç„¶è€Œåœ¨è³‡è¨Šçˆ†ç‚¸çš„æ™‚ä»£\nä¹™ã€ç¨ç«‹æ€è€ƒçš„èƒ½åŠ›é¡¯å¾—å°¤ç‚ºé‡è¦\nä¸™ã€æˆ‘å€‘æ¯å¤©æ¥æ”¶æµ·é‡çš„è¨Šæ¯\nä¸ã€è‹¥ç¼ºä¹éæ¿¾èˆ‡åˆ¤æ–·çš„æ©Ÿåˆ¶\næˆŠã€ä¾¿å®¹æ˜“éš¨æ³¢é€æµï¼Œå¤±å»è‡ªæˆ‘',
                options: [
                    'ä¸™ç”²ä¸æˆŠä¹™',
                    'ç”²ä¸™ä¸æˆŠä¹™',
                    'ç”²ä¹™ä¸™ä¸æˆŠ',
                    'ä¸™ä¸æˆŠç”²ä¹™'
                ],
                correctAnswer: [1],
                explanation: 'é‚è¼¯é †åºï¼š(ç”²)æå‡ºèƒŒæ™¯ã€Œè³‡è¨Šçˆ†ç‚¸ã€ -> (ä¸™)æ‰¿æ¥èƒŒæ™¯ã€Œæ¥æ”¶æµ·é‡è¨Šæ¯ã€ -> (ä¸)æå‡ºå‡è¨­å•é¡Œã€Œç¼ºä¹éæ¿¾ã€ -> (æˆŠ)èªªæ˜å¾Œæœã€Œéš¨æ³¢é€æµã€ -> (ä¹™)ç¸½çµè§£æ–¹ã€Œç¨ç«‹æ€è€ƒé‡è¦ã€ã€‚',
                difficulty: 'ä¸­'
            },
            {
                id: 'real_gs_3',
                type: 'group',
                category: 'è·¨é ˜åŸŸé–±è®€',
                passageTitle: 'é—œæ–¼ã€Œé»‘å¤©éµæ•ˆæ‡‰ã€',
                passageContent: `ç´è¥¿å§†Â·å¡”é›·ä¼¯åœ¨ã€Šé»‘å¤©éµæ•ˆæ‡‰ã€‹ä¸€æ›¸ä¸­æå‡ºï¼Œã€Œé»‘å¤©éµã€æ˜¯æŒ‡é‚£äº›ç™¼ç”Ÿæ©Ÿç‡æ¥µä½ã€ä½†ä¸€æ—¦ç™¼ç”Ÿå°±æœƒç”¢ç”Ÿå·¨å¤§è¡æ“Šçš„äº‹ä»¶ã€‚åœ¨ç™¼ç¾æ¾³æ´²çš„é»‘å¤©éµä¹‹å‰ï¼Œæ­æ´²äººæ™®éèªç‚ºå¤©éµéƒ½æ˜¯ç™½è‰²çš„ã€‚ã€Œé»‘å¤©éµã€çš„å­˜åœ¨è­‰æ˜äº†ç¶“é©—ä¸»ç¾©çš„ä¾·é™æ€§ï¼šä¸ç®¡æˆ‘å€‘çœ‹éå¤šå°‘éš»ç™½å¤©éµï¼Œéƒ½ç„¡æ³•è­‰å¯¦ã€Œæ‰€æœ‰å¤©éµéƒ½æ˜¯ç™½è‰²çš„ã€ï¼›ä½†åªè¦çœ‹è¦‹ä¸€éš»é»‘å¤©éµï¼Œå°±è¶³ä»¥æ¨ç¿»é€™å€‹çµè«–ã€‚`,
                questions: [
                    {
                        id: 'real_gs_3_1',
                        type: 'single',
                        text: 'æ ¹æ“šä¸Šæ–‡ï¼Œã€Œé»‘å¤©éµã€åœ¨å¡”é›·ä¼¯çš„ç†è«–ä¸­ï¼Œä¸»è¦è±¡å¾µä»€éº¼ï¼Ÿ',
                        options: [
                            'ä¸€ç¨®ç¨€æœ‰çš„ä¿è‚²é¡å‹•ç‰©',
                            'å…·æœ‰æ¯€æ»…æ€§çš„å¤©ç„¶ç½å®³',
                            'ä¸å¯é æ¸¬ä¸”è¡æ“Šå·¨å¤§çš„é›¢ç¾¤äº‹ä»¶',
                            'äººé¡èªçŸ¥ä¸Šçš„è¦–è¦ºèª¤å·®'
                        ],
                        correctAnswer: [2],
                        explanation: 'æ–‡ä¸­æåˆ°ã€Œç™¼ç”Ÿæ©Ÿç‡æ¥µä½ã€ä½†ä¸€æ—¦ç™¼ç”Ÿå°±æœƒç”¢ç”Ÿå·¨å¤§è¡æ“Šçš„äº‹ä»¶ã€ï¼Œæ•…é¸Cã€‚'
                    },
                    {
                        id: 'real_gs_3_2',
                        type: 'single',
                        text: 'é—œæ–¼æ–‡ä¸­æåˆ°çš„ã€Œç¶“é©—ä¸»ç¾©çš„ä¾·é™æ€§ã€ï¼Œä¸‹åˆ—è§£é‡‹ä½•è€…æœ€æ°ç•¶ï¼Ÿ',
                        options: [
                            'éå»çš„ç¶“é©—ä¸¦ä¸èƒ½ä¿è­‰æœªä¾†çš„çµ•å°çœŸç†',
                            'ç¶“é©—è¶Šå¤šçš„äººï¼Œè¶Šå®¹æ˜“çŠ¯éŒ¯',
                            'åªæœ‰è¦ªçœ¼è¦‹åˆ°çš„äº‹ç‰©æ‰æ˜¯çœŸå¯¦çš„',
                            'ç§‘å­¸å¯¦é©—çš„æ•¸æ“šå¾€å¾€æ˜¯é€ å‡çš„'
                        ],
                        correctAnswer: [0],
                        explanation: 'æ–‡ä¸­ä»¥ç™½å¤©éµç‚ºä¾‹ï¼Œèªªæ˜éå¾€ç¶“é©—(çœ‹éç„¡æ•¸ç™½å¤©éµ)ç„¡æ³•æ¦‚æ‹¬å…¨é«”(æ¨ç¿»æ‰€æœ‰å¤©éµçš†ç™½)ï¼Œæ•…é¸Aã€‚'
                    }
                ]
            }
        ];

        // -----------------------------------------------------------------------------
        // 2. æ“´å……ç‰ˆè³‡æ–™åº«
        // -----------------------------------------------------------------------------
        const LOGIC_CONNECTORS = [
            { type: 'è½‰æŠ˜', pairs: [['é›–ç„¶', 'ä½†æ˜¯'], ['å„˜ç®¡', 'ç„¶è€Œ'], ['é›–ç„¶', 'å»'], ['å›ºç„¶', 'ä¸é'], ['çœ‹ä¼¼', 'å¯¦å‰‡'], ['èˆ‡å…¶', 'ä¸å¦‚']] },
            { type: 'å› æœ', pairs: [['å› ç‚º', 'æ‰€ä»¥'], ['ç”±æ–¼', 'å› æ­¤'], ['æ—¢ç„¶', 'é‚£éº¼'], ['ä¹‹æ‰€ä»¥', 'æ˜¯å› ç‚º'], ['åŸºæ–¼', 'å°è‡´'], ['æƒŸå…¶', 'æ‰€ä»¥']] },
            { type: 'æ¢ä»¶', pairs: [['åªè¦', 'å°±'], ['åªæœ‰', 'æ‰'], ['é™¤é', 'å¦å‰‡'], ['ç„¡è«–', 'éƒ½'], ['ä¸€æ—¦', 'ä¾¿'], ['ä»»æ†‘', 'ä¹Ÿ']] },
            { type: 'éé€²', pairs: [['ä¸ä½†', 'è€Œä¸”'], ['ä¸åƒ…', 'é‚„'], ['ä¸åª', 'ç”šè‡³'], ['å°šä¸”', 'ä½•æ³'], ['é™¤äº†', 'æ›´'], ['éä½†', 'åè€Œ']] },
            { type: 'å‡è¨­', pairs: [['å¦‚æœ', 'å°±'], ['å€˜è‹¥', 'ä¾¿'], ['å‡å¦‚', 'é‚£éº¼'], ['å³ä½¿', 'ä¹Ÿ'], ['ç¸±ä½¿', 'ä¾ç„¶'], ['è¦æ˜¯', 'æ—©å°±']] }
        ];

        const TOPICS = [
            { title: 'æ°£å€™è®Šé·', keywords: ['æº«å®¤æ•ˆæ‡‰', 'ç¢³æ’æ”¾', 'æ¥µç«¯æ°£å€™', 'æ°¸çºŒç™¼å±•'], logic: 'äººé¡æ´»å‹•å°è‡´ç’°å¢ƒæƒ¡åŒ–' },
            { title: 'äººå·¥æ™ºæ…§', keywords: ['æ·±åº¦å­¸ç¿’', 'ç¥ç¶“ç¶²çµ¡', 'å¤§æ•¸æ“š', 'æ¼”ç®—æ³•'], logic: 'ç§‘æŠ€é€²æ­¥æ”¹è®Šç”Ÿæ´»å‹æ…‹' },
            { title: 'è¡Œç‚ºç¶“æ¿Ÿå­¸', keywords: ['å¿ƒç†å¸³æˆ¶', 'æå¤±è¦é¿', 'éŒ¨å®šæ•ˆæ‡‰', 'éç†æ€§æ±ºç­–'], logic: 'äººä¸¦éå®Œå…¨ç†æ€§çš„ç¶“æ¿Ÿå‹•ç‰©' },
            { title: 'é‡å­åŠ›å­¸', keywords: ['æ¸¬ä¸æº–åŸç†', 'ç–ŠåŠ æ…‹', 'è–›ä¸æ ¼çš„è²“', 'å¾®è§€ä¸–ç•Œ'], logic: 'ç›´è§€ç¶“é©—ä¸é©ç”¨æ–¼å¾®è§€å°ºåº¦' },
            { title: 'å‚³æŸ“ç—…å­¸', keywords: ['R0å€¼', 'ç¾¤é«”å…ç–«', 'ç–«è‹—', 'ç—…æ¯’è®Šç•°'], logic: 'é˜»æ–·å‚³æ’­éˆæ˜¯é˜²ç–«é—œéµ' },
            { title: 'æ­·å²ç¤¾æœƒå­¸', keywords: ['éšç´šæµå‹•', 'æ–‡åŒ–è³‡æœ¬', 'ç¤¾æœƒçµæ§‹', 'æ­·å²è§£é‡‹'], logic: 'çµæ§‹æ€§å› ç´ å½±éŸ¿å€‹äººå‘½é‹' },
            { title: 'ç¥ç¶“ç§‘å­¸', keywords: ['å¤šå·´èƒº', 'å‰é¡è‘‰', 'æä»æ ¸', 'ç¥ç¶“å¯å¡‘æ€§'], logic: 'å¤§è…¦çµæ§‹å½±éŸ¿æƒ…ç·’èˆ‡æ±ºç­–' },
            { title: 'å…ƒå®‡å®™', keywords: ['è™›æ“¬å¯¦å¢ƒ', 'å€å¡Šéˆ', 'æ•¸ä½åˆ†èº«', 'å»ä¸­å¿ƒåŒ–'], logic: 'æ•¸ä½èˆ‡å¯¦é«”é‚Šç•Œçš„æ¶ˆè' },
            { title: 'ESGæ°¸çºŒ', keywords: ['ç’°å¢ƒä¿è­·', 'ç¤¾æœƒè²¬ä»»', 'å…¬å¸æ²»ç†', 'ç¶ è‰²é‡‘è'], logic: 'ä¼æ¥­éœ€å…¼é¡§ç²åˆ©èˆ‡ç¤¾æœƒè²¬ä»»' },
            { title: 'èªçŸ¥å¤±èª¿', keywords: ['å¿ƒç†è¡çª', 'è‡ªæˆ‘è¾¯è­·', 'ä¿¡å¿µä¿®æ­£', 'åˆç†åŒ–'], logic: 'äººå‚¾å‘å°‹æ±‚å¿ƒç†çš„ä¸€è‡´æ€§' },
            { title: 'NFTéåŒè³ªåŒ–ä»£å¹£', keywords: ['æ•¸ä½è³‡ç”¢', 'å”¯ä¸€æ€§', 'åŠ å¯†è—è¡“', 'æ™ºèƒ½åˆç´„'], logic: 'æ•¸ä½å…§å®¹çš„æ‰€æœ‰æ¬Šé©å‘½' },
            { title: 'å›šå¾’å›°å¢ƒ', keywords: ['è³½å±€ç†è«–', 'ç´ä»€å‡è¡¡', 'åˆä½œç­–ç•¥', 'èƒŒå›'], logic: 'å€‹äººç†æ€§å¯èƒ½å°è‡´é›†é«”éç†æ€§' },
            { title: 'åŸºå› ç·¨è¼¯', keywords: ['CRISPR', 'DNAåºåˆ—', 'å€«ç†çˆ­è­°', 'ç²¾æº–é†«ç™‚'], logic: 'äººé¡æŒæ¡äº†ä¿®æ”¹ç”Ÿå‘½è—åœ–çš„èƒ½åŠ›' },
            { title: 'å»å…¨çƒåŒ–', keywords: ['ä¾›æ‡‰éˆé‡çµ„', 'è²¿æ˜“ä¿è­·', 'åœ°ç·£æ”¿æ²»', 'åœ¨åœ°åŒ–'], logic: 'å…¨çƒåˆ†å·¥é«”ç³»é¢è‡¨æŒ‘æˆ°' },
            { title: 'æ¥µç°¡ä¸»ç¾©', keywords: ['æ–·æ¨é›¢', 'æ¶ˆè²»ä¸»ç¾©', 'å¿ƒéˆè‡ªç”±', 'ç‰©è³ªæ¸›æ³•'], logic: 'å°‘å³æ˜¯å¤šçš„ç”Ÿæ´»å“²å­¸' },
            { title: 'å¹³å°ç¶“æ¿Ÿ', keywords: ['é›¶å·¥ç¶“æ¿Ÿ', 'æ¼”ç®—æ³•ç®¡ç†', 'å‹å‹•æ¬Šç›Š', 'ç¶²è·¯æ•ˆæ‡‰'], logic: 'æ–°å‹æ…‹å‹å‹•é—œä¿‚çš„èˆˆèµ·' },
            { title: 'å¾ŒçœŸç›¸æ™‚ä»£', keywords: ['å‡æ–°è', 'åŒæº«å±¤', 'è³‡è¨Šæˆ°', 'æƒ…æ„Ÿå‹•å“¡'], logic: 'æƒ…ç·’èˆ‡ä¿¡å¿µå¾€å¾€å‡Œé§•æ–¼å®¢è§€äº‹å¯¦' },
            { title: 'å¾ªç’°ç¶“æ¿Ÿ', keywords: ['å»¢æ£„ç‰©å†ç”Ÿ', 'æ–ç±ƒåˆ°æ–ç±ƒ', 'è³‡æºæ•ˆç‡', 'æ°¸çºŒè¨­è¨ˆ'], logic: 'å°‡å»¢æ£„ç‰©è½‰åŒ–ç‚ºè³‡æº' },
            { title: 'ç”Ÿç‰©å¤šæ¨£æ€§', keywords: ['æ£²åœ°ç ´å£', 'ç‰©ç¨®æ»…çµ•', 'ç”Ÿæ…‹å¹³è¡¡', 'åŸºå› åº«'], logic: 'ç”Ÿæ…‹ç³»çµ±çš„ç©©å®šä¾è³´ç‰©ç¨®è±å¯Œåº¦' },
            { title: 'æ‰¹åˆ¤æ€§æ€è€ƒ', keywords: ['ç¨ç«‹åˆ¤æ–·', 'é‚è¼¯è¬¬èª¤', 'è­‰æ“šè©•ä¼°', 'å¤šè§€é»'], logic: 'ä¸è¼•ä¿¡ã€ä¸ç›²å¾çš„æ€ç¶­æ–¹å¼' },
            { title: 'é è·å·¥ä½œ', keywords: ['æ•¸ä½éŠç‰§', 'è¦–è¨Šæœƒè­°', 'å·¥ä½œèˆ‡ç”Ÿæ´»å¹³è¡¡', 'é›²ç«¯å”ä½œ'], logic: 'å·¥ä½œå ´åŸŸèˆ‡æ™‚é–“çš„å½ˆæ€§åŒ–' },
            { title: 'æ¼”ç®—æ³•åè¦‹', keywords: ['æ•¸æ“šæ­§è¦–', 'é»‘ç®±æ±ºç­–', 'å…¬å¹³æ€§', 'ç¨‹å¼å€«ç†'], logic: 'ç§‘æŠ€å·¥å…·å¯èƒ½è¤‡è£½ç¤¾æœƒåè¦‹' },
            { title: 'ç¤¾æœƒä¼æ¥­', keywords: ['å…¬ç›Šç›®çš„', 'å•†æ¥­æ¨¡å¼', 'ç¤¾æœƒå‰µæ–°', 'å½±éŸ¿åŠ›æŠ•è³‡'], logic: 'ç”¨å•†æ¥­æ‰‹æ®µè§£æ±ºç¤¾æœƒå•é¡Œ' },
            { title: 'äººå£é«˜é½¡åŒ–', keywords: ['é•·ç…§éœ€æ±‚', 'å‹å‹•åŠ›çŸ­ç¼º', 'éŠ€é«®ç¶“æ¿Ÿ', 'ä¸–ä»£æ­£ç¾©'], logic: 'äººå£çµæ§‹æ”¹è®Šå¸¶ä¾†çš„ç¤¾æœƒæŒ‘æˆ°' },
            { title: 'æ™ºæ…§åŸå¸‚', keywords: ['ç‰©è¯ç¶²', 'å¤§æ•¸æ“šæ²»ç†', 'åŸå¸‚æ•ˆç‡', 'æ•¸ä½ç›£æ§'], logic: 'ç§‘æŠ€æå‡åŸå¸‚æ²»ç†æ•ˆèƒ½' }
        ];

        const GRAMMAR_ERRORS = [
            { type: 'è´…è©', q: 'ä»–å¿ä¿Šä¸ç¦åœ°ç¬‘äº†å‡ºä¾†ã€‚', ans: 'ã€Œå¿ä¿Šä¸ç¦ã€å³å«ç¬‘æ„ï¼Œèˆ‡ã€Œç¬‘äº†å‡ºä¾†ã€é‡è¤‡ã€‚', correct: 'ä»–å¿ä¿Šä¸ç¦ã€‚' },
            { type: 'å¥å¼é›œæ‰', q: 'é€™èµ·è»Šç¦çš„è‚‡äº‹åŸå› ï¼Œæ˜¯å› ç‚ºé…’é§•æ‰€é€ æˆçš„ã€‚', ans: 'ã€ŒåŸå› æ˜¯...ã€èˆ‡ã€Œæ˜¯...æ‰€é€ æˆçš„ã€é›œæ‰ã€‚', correct: 'é€™èµ·è»Šç¦çš„è‚‡äº‹åŸå› æ˜¯é…’é§•ã€‚' },
            { type: 'é›™é‡å¦å®šèª¤ç”¨', q: 'ç‚ºäº†é˜²æ­¢å°å·ä¸å†å…‰é¡§ï¼Œæˆ‘å€‘è£äº†ç›£è¦–å™¨ã€‚', ans: 'ã€Œé˜²æ­¢ã€èˆ‡ã€Œä¸å†ã€åˆç”¨è®Šæˆã€Œé˜²æ­¢ä¸å…‰é¡§ã€(å³å¸Œæœ›å…‰é¡§)ã€‚', correct: 'ç‚ºäº†é˜²æ­¢å°å·å†æ¬¡å…‰é¡§...' },
            { type: 'ä¸»èªä¸æ˜', q: 'çœ‹åˆ°é€™å¼µç…§ç‰‡ï¼Œè®“æˆ‘æƒ³èµ·äº†ç«¥å¹´å¾€äº‹ã€‚', ans: 'ç¼ºä¸»èªã€‚', correct: 'é€™å¼µç…§ç‰‡è®“æˆ‘æƒ³èµ·äº†ç«¥å¹´å¾€äº‹ã€‚' },
            { type: 'æ­é…ä¸ç•¶', q: 'æˆ‘å€‘æ‡‰è©²è¦æ”¹å–„ç”Ÿæ´»å“è³ªçš„æ°´æº–ã€‚', ans: 'ã€Œæ”¹å–„ã€èˆ‡ã€Œæ°´æº–ã€ä¸æ­é…ï¼Œæ‡‰ç‚ºã€Œæå‡æ°´æº–ã€æˆ–ã€Œæ”¹å–„å“è³ªã€ã€‚', correct: 'æˆ‘å€‘æ‡‰è©²è¦æå‡ç”Ÿæ´»å“è³ªçš„æ°´æº–ã€‚' },
            { type: 'èªæ„çŸ›ç›¾', q: 'é€™å¤§æ¦‚æ˜¯ä»–ç¢ºå®šçš„ç­”æ¡ˆã€‚', ans: 'ã€Œå¤§æ¦‚ã€è¡¨æ¨æ¸¬ï¼Œã€Œç¢ºå®šã€è¡¨è‚¯å®šï¼Œå‰å¾ŒçŸ›ç›¾ã€‚', correct: 'é€™å¤§æ¦‚æ˜¯ä»–çš„ç­”æ¡ˆã€‚' },
            { type: 'é‡è©èª¤ç”¨', q: 'é€™æ˜¯ä¸€ä½æˆ‘å‰›è²·çš„æ›¸ã€‚', ans: 'ã€Œä½ã€ç”¨æ–¼äººï¼Œã€Œæœ¬ã€ç”¨æ–¼æ›¸ã€‚', correct: 'é€™æ˜¯æˆ‘å‰›è²·çš„ä¸€æœ¬æ›¸ã€‚' },
            { type: 'ä¸åˆé‚è¼¯', q: 'ä»–æ˜¯çœ¾å¤šæ­»é›£è€…ä¸­ï¼Œå”¯ä¸€å€–å­˜çš„äººã€‚', ans: 'æ—¢ç„¶å€–å­˜ï¼Œå°±ä¸æ˜¯æ­»é›£è€…ã€‚', correct: 'ä»–æ˜¯é€™å ´ç½é›£ä¸­ï¼Œå”¯ä¸€çš„å€–å­˜è€…ã€‚' },
            { type: 'æˆåˆ†æ®˜ç¼º', q: 'ç¶“éé€™æ¬¡æ•™è¨“ï¼Œä½¿æˆ‘æ˜ç™½åšäººçš„é“ç†ã€‚', ans: 'ç¼ºä¸»èªï¼Œæ¿«ç”¨ä»‹è©ã€Œç¶“é...ä½¿...ã€ã€‚', correct: 'ç¶“éé€™æ¬¡æ•™è¨“ï¼Œæˆ‘æ˜ç™½äº†åšäººçš„é“ç†ã€‚' },
            { type: 'æŒ‡ä»£ä¸æ˜', q: 'å¼µä¸‰å’Œæå››ç´„å¥½åœ¨å’–å•¡å»³è¦‹é¢ï¼Œä¸ä¸€æœƒå…’ä»–å°±ä¾†äº†ã€‚', ans: 'ã€Œä»–ã€æŒ‡ä»£ä¸æ˜ï¼Œä¸çŸ¥æ˜¯å¼µä¸‰é‚„æ˜¯æå››ã€‚', correct: '...ä¸ä¸€æœƒå…’å¼µä¸‰å°±ä¾†äº†ã€‚' },
            { type: 'è©åºä¸ç•¶', q: 'æ•…å®®å±•å‡ºäº†å¹¾åƒå¹´å‰æ–°å‡ºåœŸçš„æ–‡ç‰©ã€‚', ans: 'ã€Œå¹¾åƒå¹´å‰ã€ä¿®é£¾ã€Œæ–°å‡ºåœŸã€ä¸ç•¶ã€‚', correct: 'æ•…å®®å±•å‡ºäº†æ–°å‡ºåœŸçš„å¹¾åƒå¹´å‰çš„æ–‡ç‰©ã€‚' },
            { type: 'ä¸€é¢å°å…©é¢', q: 'é€™å ´æ¯”è³½èƒ½å¦ç²å‹ï¼Œé—œéµåœ¨æ–¼éšŠå“¡çš„åŠªåŠ›ã€‚', ans: 'ã€Œèƒ½å¦ã€æ˜¯å…©é¢ï¼Œã€ŒåŠªåŠ›ã€æ˜¯ä¸€é¢ã€‚', correct: 'é€™å ´æ¯”è³½èƒ½å¦ç²å‹ï¼Œé—œéµåœ¨æ–¼éšŠå“¡æ˜¯å¦åŠªåŠ›ã€‚' },
            { type: 'é—œè¯è©èª¤ç”¨', q: 'æ—¢ç„¶å¤©æ°£é€™éº¼å¥½ï¼Œä½†æ˜¯æˆ‘å€‘é‚„æ˜¯å»çˆ¬å±±å§ã€‚', ans: 'ã€Œæ—¢ç„¶ã€æ‡‰æ­é…ã€Œå°±ã€ï¼Œã€Œä½†æ˜¯ã€è¡¨è½‰æŠ˜ä¸åˆèªæ„ã€‚', correct: 'æ—¢ç„¶å¤©æ°£é€™éº¼å¥½ï¼Œæˆ‘å€‘å°±å»çˆ¬å±±å§ã€‚' },
            { type: 'ä¿®é£¾èªå¤šé¤˜', q: 'ä»–é‚£é›™çœ¼ç›ç‚¯ç‚¯æœ‰ç¥åœ°æ³¨è¦–è‘—å‰æ–¹ã€‚', ans: 'ã€Œç‚¯ç‚¯æœ‰ç¥ã€æœ¬èº«å·²å«æ³¨è¦–æ…‹ï¼Œæˆ–å½¢å®¹çœ¼ç›ï¼Œä½œç‹€èªç¨é¡¯ç´¯è´…ã€‚', correct: 'ä»–ç‚¯ç‚¯æœ‰ç¥åœ°æ³¨è¦–è‘—å‰æ–¹ã€‚' },
            { type: 'æ•¬è©èª¤ç”¨', q: 'æ­¡è¿è’è‡¨å¯’èˆï¼Œé€™æ˜¯æˆ‘çš„æ¦®å¹¸ã€‚', ans: 'ã€Œè’è‡¨ã€ç”¨æ–¼è²´è³“ï¼Œã€Œå¯’èˆã€ç‚ºè‡ªè¬™ï¼Œæ­é…å°šå¯ã€‚', correct: 'è«‹æ‚¨æŒ‡æ•™æˆ‘çš„ä½œå“ã€‚' }
        ];

        const REORDER_TEMPLATES = [
            { context: 'é–±è®€çš„ç›Šè™•', parts: ['é–±è®€ä¸åƒ…èƒ½å¢å»£è¦‹è', 'æ›´èƒ½åŸ¹é¤Šç¨ç«‹æ€è€ƒçš„èƒ½åŠ›', 'åœ¨é€™å€‹è³‡è¨Šç¢ç‰‡åŒ–çš„æ™‚ä»£', 'æ·±é–±è®€é¡¯å¾—å½Œè¶³çè²´'], order: [2, 3, 0, 1] },
            { context: 'è«–æˆåŠŸèˆ‡å¤±æ•—', parts: ['å¤±æ•—ä¸¦ä¸å¯æ€•', 'å¯æ€•çš„æ˜¯å¾æ­¤ä¸€è¹¶ä¸æŒ¯', 'åªè¦èƒ½å¾å¤±æ•—ä¸­æ±²å–æ•™è¨“', 'ä¾¿æ˜¯é€šå¾€æˆåŠŸçš„é¤Šåˆ†'], order: [0, 1, 2, 3] },
            { context: 'ç§‘æŠ€èˆ‡ç”Ÿæ´»', parts: ['ç§‘æŠ€åŸæœ¬æ˜¯ç‚ºäº†ä¾¿åˆ©ç”Ÿæ´»', 'ä½†è‹¥éåº¦ä¾è³´ç§‘æŠ€', 'åè€Œå¯èƒ½æˆç‚ºç§‘æŠ€çš„å¥´éš¸', 'å–ªå¤±äº†ç”Ÿæ´»çš„è‡ªä¸»æ¬Š'], order: [0, 1, 2, 3] },
            { context: 'ç’°å¢ƒä¿è­·', parts: ['å¤§è‡ªç„¶æœ‰å…¶é‹ä½œè¦å¾‹', 'äººé¡è‹¥å¦„æƒ³å¾æœè‡ªç„¶', 'å¿…å°‡æ‹›è‡´å¤§è‡ªç„¶çš„åæ’²', 'å”¯æœ‰å­¸æœƒèˆ‡è‡ªç„¶å…±å­˜', 'æ‰èƒ½æ°¸çºŒç™¼å±•'], order: [0, 1, 2, 3, 4] },
            { context: 'è—è¡“é‘‘è³', parts: ['è—è¡“ä¸åªæ˜¯ç¾çš„å‘ˆç¾', 'æ›´æ˜¯å‰µä½œè€…å¿ƒéˆçš„æŠ•å°„', 'é€éæ¬£è³è—è¡“ä½œå“', 'æˆ‘å€‘å¾—ä»¥çªºè¦‹è—è¡“å®¶çš„å…§å¿ƒä¸–ç•Œ'], order: [0, 1, 2, 3] },
            { context: 'æ™‚é–“ç®¡ç†', parts: ['æ™‚é–“å°æ¯å€‹äººéƒ½æ˜¯å…¬å¹³çš„', 'å·®åˆ¥åœ¨æ–¼å¦‚ä½•é‹ç”¨', 'å–„ç”¨é›¶ç¢æ™‚é–“çš„äºº', 'å¾€å¾€èƒ½ç´¯ç©é©šäººçš„æˆæœ'], order: [0, 1, 2, 3] },
            { context: 'äººéš›æºé€š', parts: ['å‚¾è½æ˜¯æºé€šçš„ç¬¬ä¸€æ­¥', 'è‹¥åªé¡§è‘—è¡¨é”è‡ªå·±', 'å¾€å¾€æœƒå¿½ç•¥å°æ–¹çš„æ„Ÿå—', 'é€ æˆæºé€šçš„éšœç¤™'], order: [0, 1, 2, 3] },
            { context: 'å‚³çµ±èˆ‡å‰µæ–°', parts: ['å‰µæ–°ä¸¦éå®Œå…¨å±æ£„å‚³çµ±', 'è€Œæ˜¯åœ¨å‚³çµ±çš„åŸºç¤ä¸Š', 'æ³¨å…¥æ–°çš„æ™‚ä»£ç²¾ç¥', 'è®“å‚³çµ±æ–‡åŒ–é‡ç²æ–°ç”Ÿ'], order: [0, 1, 2, 3] },
            { context: 'æƒ…ç·’ç®¡ç†', parts: ['æƒ…ç·’æœ¬èº«æ²’æœ‰å°éŒ¯', 'é—œéµåœ¨æ–¼å¦‚ä½•è¡¨é”', 'é©åº¦å®£æ´©æœ‰ç›Šèº«å¿ƒ', 'å£“æŠ‘åè€Œå¯èƒ½é€ æˆå…§å‚·'], order: [0, 1, 2, 3] },
            { context: 'å­¸ç¿’æ…‹åº¦', parts: ['å­¸å•ä¹‹é“ç„¡ä»–', 'æ±‚å…¶æ”¾å¿ƒè€Œå·²', 'ä¿æŒå¥½å¥‡å¿ƒ', 'æ˜¯å­¸ç¿’çš„æœ€ä½³å‹•åŠ›'], order: [0, 1, 2, 3] }
        ];

        const RHETORIC = [
            { name: 'è­¬å–»', q: 'é‚£é›ªç™½çš„ç¾½æ¯›ï¼Œå°±åƒæ˜¯å¤©ä½¿çš„ç¿…è†€ã€‚', key: 'åƒ(æ˜å–»)' },
            { name: 'è½‰åŒ–', q: 'æ˜¥é¢¨æº«æŸ”åœ°æ’«æ‘¸è‘—å¤§åœ°ã€‚', key: 'æ’«æ‘¸(æ“¬äºº)' },
            { name: 'èª‡é£¾', q: 'ç™½é«®ä¸‰åƒä¸ˆï¼Œç·£æ„ä¼¼å€‹é•·ã€‚', key: 'ä¸‰åƒä¸ˆ' },
            { name: 'æ˜ è¥¯', q: 'å‰µæ¥­çš„äººå¤šï¼ŒæˆåŠŸçš„äººå°‘ã€‚', key: 'å¤švså°‘' },
            { name: 'å€Ÿä»£', q: 'ä½•ä»¥è§£æ†‚ï¼Ÿå”¯æœ‰æœåº·ã€‚', key: 'æœåº·(ä»£é…’)' },
            { name: 'å±¤é', q: 'å¤©æ™‚ä¸å¦‚åœ°åˆ©ï¼Œåœ°åˆ©ä¸å¦‚äººå’Œã€‚', key: 'å±¤å±¤éé€²' },
            { name: 'æ’æ¯”', q: 'ç‡•å­å»äº†ï¼Œæœ‰å†ä¾†çš„æ™‚å€™ï¼›æ¥ŠæŸ³æ¯äº†ï¼Œæœ‰å†é’çš„æ™‚å€™ï¼›æ¡ƒèŠ±è¬äº†ï¼Œæœ‰å†é–‹çš„æ™‚å€™ã€‚', key: 'çµæ§‹ç›¸ä¼¼å¥é€£ç”¨' },
            { name: 'è¨­å•', q: 'å•æ¸ å“ªå¾—æ¸…å¦‚è¨±ï¼Ÿç‚ºæœ‰æºé ­æ´»æ°´ä¾†ã€‚', key: 'è‡ªå•è‡ªç­”' },
            { name: 'å°å¶', q: 'è‰æ¯é·¹çœ¼ç–¾ï¼Œé›ªç›¡é¦¬è¹„è¼•ã€‚', key: 'å­—æ•¸ç›¸ç­‰ã€çµæ§‹ç›¸åŒ' },
            { name: 'é›™é—œ', q: 'æ±é‚Šæ—¥å‡ºè¥¿é‚Šé›¨ï¼Œé“æ˜¯ç„¡æ™´å»æœ‰æ™´ã€‚', key: 'æ™´(æƒ…)' },
            { name: 'å€’å', q: 'ä½ é€™äººçœŸè°æ˜ï¼Œé€™éº¼ç°¡å–®çš„å­—éƒ½æœƒå¯«éŒ¯ã€‚', key: 'è¨€ä¸ç”±è¡·' },
            { name: 'é ‚çœŸ', q: 'æ­¸ä¾†è¦‹å¤©å­ï¼Œå¤©å­åæ˜å ‚ã€‚', key: 'å°¾é¦–ç›¸æ¥' },
            { name: 'ç§»è¦º(é€šæ„Ÿ)', q: 'å¾®é¢¨éè™•ï¼Œé€ä¾†ç¸·ç¸·æ¸…é¦™ï¼Œå½·å½¿é è™•é«˜æ¨“ä¸Šæ¸ºèŒ«çš„æ­Œè²ã€‚', key: 'å—…è¦ºé€šè½è¦º' },
            { name: 'äº’æ–‡', q: 'ç§¦æ™‚æ˜æœˆæ¼¢æ™‚é—œã€‚', key: 'ç§¦æ¼¢ä¹‹æ˜æœˆèˆ‡é—œ' },
            { name: 'è±¡å¾µ', q: 'å­¤å¸†é å½±ç¢§ç©ºç›¡ã€‚', key: 'å­¤å¸†(éŠå­)' }
        ];

        // -----------------------------------------------------------------------------
        // Helper: Fisher-Yates Shuffle
        // -----------------------------------------------------------------------------
        const fisherYatesShuffle = (array) => {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        };

        // -----------------------------------------------------------------------------
        // Generator
        // -----------------------------------------------------------------------------
        const generateGeneralMock = (type, itemIndex, variantCount) => {
            const shuffle = (arr) => [...arr].sort(() => 0.5 - Math.random());
            const isReview = variantCount > 0;
            const reviewLabel = isReview ? 'ã€ğŸ’¡è¤‡ç¿’é¡Œã€‘' : '';

            if (type === 'logic_fill') {
                const logic = LOGIC_CONNECTORS[itemIndex % LOGIC_CONNECTORS.length];
                const pairIndex = variantCount % logic.pairs.length;
                const pair = logic.pairs[pairIndex];
                const wrongPairs = shuffle(LOGIC_CONNECTORS.flatMap(l => l.pairs).filter(p => p[0] !== pair[0])).slice(0, 3);
                
                let subjects = ['é€™é …è¨ˆç•«', 'é€™å€‹ææ¡ˆ', 'é€™å ´æ¯”è³½', 'é€™ä»½å ±å‘Š', 'é€™å€‹ä»»å‹™'];
                let sub = subjects[variantCount % subjects.length];
                
                let sentence = "";
                if (logic.type === 'è½‰æŠ˜') sentence = `______${sub}å›°é›£é‡é‡ï¼Œ______æˆ‘å€‘çµ•ä¸æœƒè¼•è¨€æ”¾æ£„ã€‚`;
                else if (logic.type === 'å› æœ') sentence = `______é€£æ—¥å¤§é›¨å°è‡´è¦–ç·šä¸ä½³ï¼Œ______é«˜é€Ÿå…¬è·¯ä¸Šç™¼ç”Ÿäº†è¿½æ’äº‹æ•…ã€‚`;
                else if (logic.type === 'æ¢ä»¶') sentence = `______å¤§å®¶åœ˜çµä¸€è‡´ï¼Œ______ä¸€å®šèƒ½åº¦éé€™æ¬¡çš„é›£é—œã€‚`;
                else sentence = `ä»–______ç²¾é€šè‹±èªï¼Œ______é‚„æœƒèªªä¸€å£æµåˆ©çš„æ³•èªã€‚`;

                return {
                    category: 'é‚è¼¯å¡«ç©º',
                    text: `${reviewLabel} è«‹ä¾æ“šæ–‡æ„é‚è¼¯ï¼Œé¸å‡ºæœ€é©åˆå¡«å…¥ä¸‹åˆ—ç©ºæ ¼çš„è©èªï¼š\nã€Œ${sentence}ã€`,
                    options: [
                        `${pair[0]} ... ${pair[1]}`,
                        `${wrongPairs[0][0]} ... ${wrongPairs[0][1]}`,
                        `${wrongPairs[1][0]} ... ${wrongPairs[1][1]}`,
                        `${wrongPairs[2][0]} ... ${wrongPairs[2][1]}`
                    ],
                    explanation: `æœ¬å¥ç‚º${logic.type}é—œä¿‚ï¼Œæ‡‰ä½¿ç”¨ã€Œ${pair[0]}...${pair[1]}ã€ã€‚`,
                    correctIndex: 0,
                    isReview
                };
            } else if (type === 'reading') {
                const topic = TOPICS[itemIndex % TOPICS.length];
                const content = `è¿‘å¹´ä¾†ï¼Œé—œæ–¼ã€Œ${topic.title}ã€çš„è¨è«–ç”šå›‚å¡µä¸Šã€‚å°ˆå®¶æŒ‡å‡ºï¼Œ${topic.keywords.join('ã€')}ç­‰æ¦‚å¿µæ˜¯ç†è§£æ­¤è­°é¡Œçš„é—œéµã€‚é€™é¡¯ç¤ºäº†${topic.logic}ã€‚`;
                const qTexts = [
                    `è«‹å•æœ¬æ–‡çš„ä¸»æ—¨æœ€æ¥è¿‘ä¸‹åˆ—ä½•è€…ï¼Ÿ`,
                    `æ ¹æ“šæœ¬æ–‡ï¼Œä½œè€…å°ã€Œ${topic.title}ã€çš„è§€é»ç‚ºä½•ï¼Ÿ`,
                    `ä¸‹åˆ—é—œæ–¼ã€Œ${topic.title}ã€çš„æ•˜è¿°ï¼Œä½•è€…ç¬¦åˆæ–‡æ„ï¼Ÿ`
                ];
                const qText = qTexts[variantCount % qTexts.length];

                return {
                    category: 'é–±è®€ç†è§£',
                    text: `${reviewLabel} é–±è®€ä¸‹æ–‡ï¼š\nã€Œ${content}ã€\n${qText}`,
                    options: [
                        `${topic.logic}`,
                        `${topic.title}å·²ç¶“æ˜¯éæ™‚çš„è­°é¡Œ`,
                        `å°ˆå®¶å°æ–¼${topic.title}æŒä¿ç•™æ…‹åº¦`,
                        `${topic.keywords[0]}æ˜¯è§£æ±ºå•é¡Œçš„å”¯ä¸€é€”å¾‘`
                    ],
                    explanation: `æ–‡ä¸­æåˆ°ã€Œé€™é¡¯ç¤ºäº†...ã€å¾Œæ¥çš„çµè«–å³ç‚ºä¸»æ—¨ï¼Œæ•…æ‡‰é¸ã€Œ${topic.logic}ã€ã€‚`,
                    correctIndex: 0,
                    isReview
                };
            } else if (type === 'grammar') {
                const err = GRAMMAR_ERRORS[itemIndex % GRAMMAR_ERRORS.length];
                const correctSentences = [
                    `ç¶“éè€å¸«çš„æŒ‡å°ï¼Œä»–çš„æˆç¸¾é€²æ­¥äº†ã€‚`, `çª—å¤–çš„é›¨æ·…ç€ç€åœ°ä¸‹è‘—ã€‚`, `èª å¯¦æ˜¯åšäººçš„åŸºæœ¬é“ç†ã€‚`,
                    `é–±è®€èƒ½è®“æˆ‘å€‘çœ‹è¦‹ä¸ä¸€æ¨£çš„ä¸–ç•Œã€‚`, `é‹å‹•æœ‰åŠ©æ–¼èº«å¿ƒå¥åº·ã€‚`, `æ™‚é–“ä¸ç­‰äººï¼Œæˆ‘å€‘å¿…é ˆæŠŠæ¡ç•¶ä¸‹ã€‚`
                ];
                const others = shuffle(correctSentences).slice(0, 3);
                return {
                    category: 'èªç—…åˆ¤æ–·',
                    text: `${reviewLabel} ä¸‹åˆ—æ–‡å¥ï¼Œä½•è€…çŠ¯äº†èªæ³•ä¸Šçš„éŒ¯èª¤ï¼ˆå¦‚è´…è©ã€çŸ›ç›¾ã€é›œæ‰ç­‰ï¼‰ï¼Ÿ`,
                    options: [ `${err.q}`, others[0], others[1], others[2] ],
                    explanation: `é¸é …Aã€Œ${err.q}ã€çŠ¯äº†${err.type}çš„éŒ¯èª¤ã€‚${err.ans}æ‡‰æ”¹ç‚ºï¼šã€Œ${err.correct}ã€ã€‚`,
                    correctIndex: 0,
                    isReview
                };
            } else if (type === 'reorder') {
                const t = REORDER_TEMPLATES[itemIndex % REORDER_TEMPLATES.length];
                const labels = ['ç”²', 'ä¹™', 'ä¸™', 'ä¸', 'æˆŠ'].slice(0, t.parts.length);
                const partText = t.parts.map((p, i) => `${labels[i]}ã€${p}`).join('\n');
                const correctSeq = t.order.map(i => labels[i]).join('');
                
                const generateWrongSeq = () => {
                    let wrong = shuffle([...t.order]);
                    let seq = wrong.map(i => labels[i]).join('');
                    return seq === correctSeq ? generateWrongSeq() : seq;
                };

                return {
                    category: 'æ–‡å¥é‡çµ„',
                    text: `${reviewLabel} ä¸‹åˆ—æ–‡å¥é‡çµ„ï¼Œé †åºæœ€æ°ç•¶çš„æ˜¯ï¼š\n${partText}`,
                    options: [ `${correctSeq}`, generateWrongSeq(), generateWrongSeq(), generateWrongSeq() ],
                    explanation: `æœ¬æ®µæ–‡å­—çš„ä¸»é¡Œæ˜¯ã€Œ${t.context}ã€ã€‚ä¾æ“šæ–‡æ„é‚è¼¯ï¼Œæ­£ç¢ºé †åºæ‡‰ç‚ºï¼š${t.order.map(i => t.parts[i]).join(' -> ')}ã€‚`,
                    correctIndex: 0,
                    isReview
                };
            } else {
                const r = RHETORIC[itemIndex % RHETORIC.length];
                const wrong = shuffle(RHETORIC.filter(x => x.name !== r.name)).slice(0, 3).map(x => x.name);
                return {
                    category: 'ä¿®è¾­åˆ†æ',
                    text: `${reviewLabel} ã€Œ${r.q}ã€é€™å¥è©±ä½¿ç”¨äº†ä½•ç¨®ä¿®è¾­æŠ€å·§ï¼Ÿ`,
                    options: [ r.name, wrong[0], wrong[1], wrong[2] ],
                    explanation: `ã€Œ${r.q}ã€ä¸­ä½¿ç”¨äº†ã€Œ${r.key}ã€çš„æŠ€å·§ï¼Œæ•…ç‚º${r.name}ã€‚`,
                    correctIndex: 0,
                    isReview
                };
            }
        };

        const generateMockQuestions = (startId, count) => {
            const mocks = [];
            const types = ['logic_fill', 'reading', 'grammar', 'reorder', 'rhetoric'];
            let taskPool = [];
            const typeDataCounts = {
                'logic_fill': LOGIC_CONNECTORS.length,
                'reading': TOPICS.length,
                'grammar': GRAMMAR_ERRORS.length,
                'reorder': REORDER_TEMPLATES.length,
                'rhetoric': RHETORIC.length
            };
            let totalBaseItems = 0;
            for(let k in typeDataCounts) totalBaseItems += typeDataCounts[k];
            
            const loopsNeeded = Math.ceil(count / totalBaseItems) + 1;

            for (let loop = 0; loop < loopsNeeded; loop++) {
                types.forEach(type => {
                    const maxIdx = typeDataCounts[type];
                    for (let i = 0; i < maxIdx; i++) {
                        taskPool.push({ type, itemIndex: i, variantCount: loop });
                    }
                });
            }

            taskPool = fisherYatesShuffle(taskPool);
            const selectedTasks = taskPool.slice(0, count);

            selectedTasks.forEach((task, i) => {
                const isMulti = Math.random() > 0.85; 
                const content = generateGeneralMock(task.type, task.itemIndex, task.variantCount);
                let finalOptions = content.options.map((text, idx) => ({ 
                    text, 
                    isCorrect: idx === content.correctIndex 
                }));
                finalOptions = fisherYatesShuffle(finalOptions);
                let correctIndices = [];
                finalOptions.forEach((opt, idx) => { if (opt.isCorrect) correctIndices.push(idx); });

                if (isMulti) {
                    correctIndices = [0, 1]; 
                    content.explanation += " (æ­¤é¡Œç‚ºæ¨¡æ“¬å¤šé¸ï¼Œæ­£ç¢ºç­”æ¡ˆåŒ…å« A èˆ‡ B)";
                }
                const answerLabels = correctIndices.map(idx => String.fromCharCode(65 + idx)).join('ã€');

                mocks.push({
                    id: `mock_gs_${startId + i}`,
                    type: isMulti ? 'multi' : 'single',
                    category: content.category,
                    text: `[åœ‹ç¶œæ¨¡æ“¬ #${startId + i}] ${content.text}`,
                    options: finalOptions.map(o => o.text),
                    correctAnswer: correctIndices,
                    explanation: `${content.explanation} (æœ¬é¡Œæ­£ç¢ºç­”æ¡ˆç‚º ${answerLabels})`,
                    difficulty: ['æ˜“', 'ä¸­', 'é›£'][Math.floor(Math.random() * 3)],
                    isReview: content.isReview
                });
            });
            return mocks;
        };

        // -----------------------------------------------------------------------------
        // App Component
        // -----------------------------------------------------------------------------
        function App() {
            const [currentScreen, setCurrentScreen] = useState('home'); 
            const [questions, setQuestions] = useState([]);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [userAnswers, setUserAnswers] = useState({});
            const [markedQuestions, setMarkedQuestions] = useState(new Set()); 
            const [showExplanation, setShowExplanation] = useState(false);
            const [showGrid, setShowGrid] = useState(false); 

            useEffect(() => {
                let flattened = [];
                REAL_QUESTION_EXAMPLES.forEach(item => {
                    if (item.type === 'group') {
                        item.questions.forEach(q => {
                            flattened.push({ ...q, groupTitle: item.passageTitle, groupContent: item.passageContent, isGroup: true });
                        });
                    } else {
                        flattened.push(item);
                    }
                });
                const needed = 500 - flattened.length;
                if (needed > 0) {
                    const mocks = generateMockQuestions(flattened.length + 1, needed);
                    flattened = [...flattened, ...mocks];
                }
                setQuestions(flattened);
            }, []);

            const startExam = () => { setCurrentQuestionIndex(0); setUserAnswers({}); setMarkedQuestions(new Set()); setShowExplanation(false); setShowGrid(false); setCurrentScreen('quiz'); };
            const handleAnswerSelect = (optionIndex, isMulti) => {
                if (showExplanation) return; 
                const currentQ = questions[currentQuestionIndex];
                setUserAnswers(prev => {
                    const currentSelected = prev[currentQ.id] || [];
                    if (isMulti) {
                        return { ...prev, [currentQ.id]: currentSelected.includes(optionIndex) ? currentSelected.filter(i => i !== optionIndex) : [...currentSelected, optionIndex].sort() };
                    } else {
                        return { ...prev, [currentQ.id]: [optionIndex] };
                    }
                });
                if (!isMulti) setShowExplanation(true);
            };
            const toggleMarkQuestion = () => {
                const qId = questions[currentQuestionIndex].id;
                setMarkedQuestions(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(qId)) newSet.delete(qId); else newSet.add(qId);
                    return newSet;
                });
            };
            const calculateScore = () => {
                let rawScore = 0;
                questions.forEach(q => {
                    const userAns = userAnswers[q.id] || [];
                    const isCorrect = JSON.stringify(userAns.sort()) === JSON.stringify(q.correctAnswer.sort());
                    if (isCorrect) rawScore++;
                });
                const percentage = (rawScore / questions.length) * 100;
                let rank = percentage >= 90 ? 15 : percentage >= 85 ? 14 : percentage >= 80 ? 13 : Math.floor(percentage / 10) + 1;
                return { rawScore, total: questions.length, rank, percentage };
            };

            const QuestionGrid = ({ closeGrid }) => (
                <div className="fixed inset-0 bg-black/50 z-50 flex justify-end animate-fade-in">
                    <div className="w-full max-w-sm bg-white h-full shadow-2xl flex flex-col animate-slide-in-right">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50">
                            <h3 className="font-bold text-lg text-gray-800 flex items-center"><Icons.Grid size={20} className="mr-2"/> é¡Œç›®å°èˆª</h3>
                            <button onClick={closeGrid}><Icons.XCircle size={24} className="text-gray-500"/></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4">
                            <div className="grid grid-cols-5 gap-3">
                                {questions.map((q, idx) => {
                                    const isAnswered = userAnswers[q.id]?.length > 0;
                                    const isMarked = markedQuestions.has(q.id);
                                    let btnClass = "h-10 w-10 rounded-lg flex items-center justify-center text-sm font-medium transition relative ";
                                    if (currentQuestionIndex === idx) btnClass += "ring-2 ring-emerald-600 bg-emerald-100 text-emerald-800 font-bold ";
                                    else if (isAnswered) btnClass += "bg-emerald-600 text-white shadow-sm ";
                                    else btnClass += "bg-gray-100 text-gray-500 hover:bg-gray-200 ";
                                    return <button key={q.id} onClick={() => { setCurrentQuestionIndex(idx); setShowExplanation(false); closeGrid(); }} className={btnClass}>{idx + 1}{isMarked && <span className="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full border border-white"></span>}</button>;
                                })}
                            </div>
                        </div>
                    </div>
                </div>
            );

            if (currentScreen === 'home') return (
                <div className="flex flex-col items-center justify-center h-full p-6 space-y-8 animate-fade-in bg-gradient-to-br from-teal-50 to-emerald-50">
                    <div className="text-center space-y-4 max-w-lg">
                        <div className="bg-white p-6 rounded-2xl shadow-xl inline-block mb-2"><Icons.Brain size={64} className="text-emerald-600" /></div>
                        <h1 className="text-4xl font-extrabold text-gray-800">åœ‹ç¶œç´ é¤Š â€¢ æ¨¡æ“¬æ¸¬é©—</h1>
                        <p className="text-xl text-gray-600">é–±è®€ç†è§£ â€¢ é‚è¼¯æ¨è«– â€¢ è·¨åŸŸæ–‡æœ¬</p>
                    </div>
                    <button onClick={startExam} className="flex items-center justify-center p-5 bg-emerald-600 text-white rounded-xl shadow-lg hover:bg-emerald-700 transition transform hover:-translate-y-1"><Icons.Compass size={24} className="mr-3" /> <span className="text-xl font-bold">é–‹å§‹æ¸¬é©—</span></button>
                </div>
            );

            if (currentScreen === 'result') {
                const { rawScore, total, rank, percentage } = calculateScore();
                return (
                    <div className="flex flex-col items-center h-full bg-slate-50 p-6 overflow-y-auto">
                        <div className="w-full max-w-md space-y-6 mt-8">
                            <div className="bg-white rounded-3xl shadow-xl p-8 text-center"><h2 className="text-3xl font-extrabold text-gray-800 mb-2">æ¸¬é©—çµæŸ</h2><div className="text-6xl font-black text-gray-800 my-8">{percentage.toFixed(0)}<span className="text-2xl text-gray-400">åˆ†</span></div><div className="grid grid-cols-2 gap-4 text-left"><div className="bg-gray-50 p-4 rounded-2xl"><p className="text-xs text-gray-500 font-bold">ç­”å°é¡Œæ•¸</p><p className="text-2xl font-bold text-gray-800">{rawScore} / {total}</p></div><div className="bg-gray-50 p-4 rounded-2xl"><p className="text-xs text-gray-500 font-bold">æ›ç®—ç´šåˆ†</p><p className="text-2xl font-bold text-gray-800">{rank}</p></div></div></div>
                            <button onClick={() => setCurrentScreen('home')} className="w-full bg-emerald-600 hover:bg-emerald-700 text-white py-4 rounded-2xl font-bold shadow-lg transition">é‡è¿”é¦–é </button>
                        </div>
                    </div>
                );
            }

            // å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿ q å­˜åœ¨
            const q = questions[currentQuestionIndex];
            if (!q) return <div className="flex items-center justify-center h-full text-xl font-bold text-gray-500">è¼‰å…¥é¡Œåº«ä¸­...</div>;

            const isMulti = q.type === 'multi' || (q.correctAnswer && q.correctAnswer.length > 1);
            const currentAns = userAnswers[q.id] || [];
            
            return (
                <div className="flex flex-col h-full bg-slate-50 relative">
                    {showGrid && <QuestionGrid closeGrid={() => setShowGrid(false)} />}
                    <div className="bg-white shadow-sm px-4 py-3 flex justify-between items-center sticky top-0 z-10 border-b border-gray-100">
                        <div className="flex items-center space-x-3">
                            <button onClick={() => setCurrentScreen('home')}><Icons.Home size={20} className="text-gray-500 hover:text-gray-700" /></button>
                            <button onClick={() => setShowGrid(true)} className="flex items-center space-x-2 px-3 py-1.5 bg-gray-100 hover:bg-gray-200 rounded-lg text-gray-700 font-medium"><Icons.Grid size={18} /><span>{currentQuestionIndex + 1} / {questions.length}</span></button>
                        </div>
                        <button onClick={toggleMarkQuestion}><Icons.Flag size={20} fill={markedQuestions.has(q.id) ? "currentColor" : "none"} className={markedQuestions.has(q.id) ? "text-red-500" : "text-gray-400"} /></button>
                    </div>
                    <div className="flex-1 overflow-y-auto p-4 md:p-6 max-w-4xl mx-auto w-full scroll-smooth">
                        {q.isGroup && <div className="bg-white rounded-xl p-6 mb-6 shadow-sm border-l-4 border-emerald-500"><h3 className="font-bold text-lg text-gray-900 mb-3">{q.groupTitle}</h3><div className="prose text-gray-700">{q.groupContent}</div></div>}
                        <div className="bg-white rounded-xl p-6 shadow-sm ring-1 ring-gray-100">
                            <div className="flex items-center space-x-2 mb-4">
                                <span className={`text-xs font-bold px-2 py-1 rounded ${isMulti ? 'bg-orange-100 text-orange-800' : 'bg-emerald-100 text-emerald-800'}`}>{isMulti ? 'å¤šé¸' : 'å–®é¸'}</span>
                                <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded border border-gray-200">{q.category}</span>
                                {q.isReview && <span className="text-xs text-amber-600 bg-amber-50 px-2 py-1 rounded border border-amber-200 flex items-center animate-pulse"><Icons.Tag size={12} className="mr-1" /> è¤‡ç¿’è®Šé«”</span>}
                            </div>
                            <h2 className="text-xl font-medium text-gray-900 mb-8 leading-relaxed whitespace-pre-wrap">{q.text}</h2>
                            <div className="space-y-4">
                                {q.options.map((opt, idx) => {
                                    const isSelected = currentAns.includes(idx);
                                    let btnClass = "w-full text-left p-4 rounded-xl border transition-all flex items-start space-x-4 ";
                                    if (showExplanation) {
                                        if (q.correctAnswer.includes(idx)) btnClass += "border-green-500 bg-green-50 text-green-900";
                                        else if (isSelected) btnClass += "border-red-500 bg-red-50 text-red-900";
                                        else btnClass += "border-gray-100 text-gray-400 opacity-60";
                                    } else {
                                        if (isSelected) btnClass += "border-emerald-500 bg-emerald-50 text-emerald-900 shadow-md";
                                        else btnClass += "border-gray-200 hover:border-emerald-300 hover:bg-gray-50 text-gray-700";
                                    }
                                    return <button key={idx} onClick={() => handleAnswerSelect(idx, isMulti)} className={btnClass} disabled={showExplanation}><div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold border ${isSelected ? 'bg-emerald-600 border-emerald-600 text-white' : 'border-gray-300 text-gray-500'} ${showExplanation && q.correctAnswer.includes(idx) ? '!bg-green-500 !border-green-500 !text-white' : ''}`}>{String.fromCharCode(65 + idx)}</div><span className="pt-1">{opt}</span></button>;
                                })}
                            </div>
                            {showExplanation && <div className="mt-8 bg-blue-50 p-5 rounded-xl border border-blue-100 animate-fade-in-up"><div className="flex items-center space-x-2 text-blue-900 font-bold mb-3"><Icons.Award size={20} /><span>è§£æ</span></div><p className="text-blue-900">{q.explanation}</p></div>}
                        </div>
                    </div>
                    <div className="bg-white border-t border-gray-100 p-4 flex justify-between items-center safe-area-bottom">
                        <button onClick={() => { setShowExplanation(false); setCurrentQuestionIndex(prev => Math.max(0, prev - 1)); }} disabled={currentQuestionIndex === 0} className="flex items-center space-x-2 px-4 py-2 rounded-full text-gray-600 hover:bg-gray-100 disabled:opacity-30"><Icons.ChevronLeft size={20} /> <span>ä¸Šä¸€é¡Œ</span></button>
                        {!showExplanation ? (isMulti ? <button onClick={() => setShowExplanation(true)} className="bg-orange-500 hover:bg-orange-600 text-white px-8 py-2.5 rounded-full font-bold shadow-md">ç¢ºèªç­”æ¡ˆ</button> : <span className="text-sm text-gray-400 font-medium hidden md:block animate-pulse">è«‹é»é¸é¸é …</span>) : <button onClick={() => { if (currentQuestionIndex < questions.length - 1) { setShowExplanation(false); setCurrentQuestionIndex(prev => prev + 1); } else { setCurrentScreen('result'); setShowGrid(false); } }} className="bg-emerald-600 hover:bg-emerald-700 text-white px-8 py-2.5 rounded-full font-bold shadow-md flex items-center">{currentQuestionIndex === questions.length - 1 ? 'å®Œæˆæ¸¬é©—' : 'ä¸‹ä¸€é¡Œ'} <Icons.ChevronRight size={18} className="ml-1"/></button>}
                        {(!showExplanation && !isMulti) && <div className="w-20 md:hidden"></div>}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>